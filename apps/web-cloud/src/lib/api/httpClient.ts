// API base URL - includes /api prefix for versioned endpoints
export const API_BASE = import.meta.env?.VITE_API_BASE || import.meta.env?.BACKEND_BASE_URL || 'http://localhost:3000/api'

export type StoredUser = {
    email?: string | null
    role?: string | null
    name?: string | null
}

export function getStoredTokens(): { accessToken: string | null; refreshToken: string | null } {
    if (typeof window === 'undefined') return { accessToken: null, refreshToken: null }
    return {
        accessToken: localStorage.getItem('authToken'),
        refreshToken: localStorage.getItem('refreshToken')
    }
}

export function setStoredTokens(accessToken: string, refreshToken: string): void {
    if (typeof window === 'undefined') return
    localStorage.setItem('authToken', accessToken)
    localStorage.setItem('refreshToken', refreshToken)
}

export function setStoredUser(user: StoredUser): void {
    if (typeof window === 'undefined') return
    if (user.email) localStorage.setItem('userEmail', user.email)
    if (user.role) localStorage.setItem('userRole', user.role)
    if (user.name) localStorage.setItem('userName', user.name)
}

export function clearStoredSession(): void {
    if (typeof window === 'undefined') return
    localStorage.removeItem('authToken')
    localStorage.removeItem('refreshToken')
    localStorage.removeItem('userId')
    localStorage.removeItem('userEmail')
    localStorage.removeItem('userRole')
    localStorage.removeItem('userName')
}

export function requireAccessToken(): string {
    const { accessToken } = getStoredTokens()
    if (!accessToken) {
        throw new Error('Authentication required')
    }
    return accessToken
}

let refreshingPromise: Promise<string | null> | null = null

export async function refreshAccessToken(fetchImpl: typeof fetch = fetch): Promise<string | null> {
    if (typeof window === 'undefined') return null
    const { refreshToken } = getStoredTokens()
    if (!refreshToken) return null

    if (!refreshingPromise) {
        refreshingPromise = (async () => {
            const response = await fetchImpl(`${API_BASE}/v1/auth/refresh`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ refreshToken })
            })

            if (!response.ok) {
                clearStoredSession()
                return null
            }

            const data = await response.json()
            // API returns {success: true, data: {accessToken, refreshToken}, meta: {...}}
            const tokens = data.data || data
            setStoredTokens(tokens.accessToken, tokens.refreshToken)
            return tokens.accessToken as string
        })()

        refreshingPromise.finally(() => {
            refreshingPromise = null
        })
    }

    return refreshingPromise
}

export async function authorizedFetch(input: RequestInfo, init: RequestInit = {}): Promise<Response> {
    const headers = new Headers(init.headers || {})
    const { accessToken } = getStoredTokens()
    const isRefreshCall = typeof input === 'string' && input.includes('/auth/refresh')

    if (accessToken && !headers.has('Authorization') && !init.credentials) {
        headers.set('Authorization', `Bearer ${accessToken}`)
    }

    const doFetch = () => fetch(input, { ...init, headers })
    let response = await doFetch()

    if (response.status !== 401 || isRefreshCall) {
        return response
    }

    const newToken = await refreshAccessToken()
    if (newToken) {
        headers.set('Authorization', `Bearer ${newToken}`)
        response = await doFetch()
    }

    return response
}

export async function apiJson<T>(input: string, init?: RequestInit): Promise<T> {
    const response = await authorizedFetch(input, init)
    if (!response.ok) {
        const message = await response.text()
        throw new Error(message || `HTTP ${response.status}`)
    }
    const json = await response.json()
    return json as T
}

type ApiEnvelope<T> = {
    data: T
    meta?: unknown
    success?: boolean
}

export function unwrapApiData<T>(payload: ApiEnvelope<T> | T): T {
    if (payload && typeof payload === 'object' && 'data' in payload) {
        return (payload as ApiEnvelope<T>).data
    }
    return payload as T
}

export async function apiJsonData<T>(input: string, init?: RequestInit): Promise<T> {
    const payload = await apiJson<ApiEnvelope<T> | T>(input, init)
    return unwrapApiData(payload)
}

type CacheEntry = {
    expiresAt: number
    value: unknown
    isError: boolean
}

const inflightRequests = new Map<string, Promise<unknown>>()
const responseCache = new Map<string, CacheEntry>()

/**
 * Clears the in-memory GET cache used by apiJsonCached/apiJsonDataCached.
 *
 * This is primarily used by unit tests to ensure deterministic assertions on fetch calls.
 */
export function clearApiCache(): void {
    inflightRequests.clear()
    responseCache.clear()
}

function buildCacheKey(input: string, init?: RequestInit): string {
    const method = init?.method?.toUpperCase() ?? 'GET'
    return `${method}:${input}`
}

function readCache<T>(key: string): T | null {
    const cached = responseCache.get(key)
    if (!cached) return null
    if (cached.expiresAt <= Date.now()) {
        responseCache.delete(key)
        return null
    }
    if (cached.isError) {
        throw cached.value
    }
    return cached.value as T
}

export async function apiJsonCached<T>(
    input: string,
    init?: RequestInit,
    options?: { ttlMs?: number; errorTtlMs?: number }
): Promise<T> {
    const method = init?.method?.toUpperCase() ?? 'GET'
    if (method !== 'GET') {
        return apiJson<T>(input, init)
    }

    const key = buildCacheKey(input, init)
    const cached = readCache<T>(key)
    if (cached !== null) return cached

    const existing = inflightRequests.get(key)
    if (existing) return existing as Promise<T>

    const ttlMs = options?.ttlMs ?? 5000
    const errorTtlMs = options?.errorTtlMs ?? 2000

    const promise = apiJson<T>(input, init)
        .then((data) => {
            responseCache.set(key, {
                expiresAt: Date.now() + ttlMs,
                value: data,
                isError: false
            })
            return data
        })
        .catch((error) => {
            responseCache.set(key, {
                expiresAt: Date.now() + errorTtlMs,
                value: error,
                isError: true
            })
            throw error
        })
        .finally(() => {
            inflightRequests.delete(key)
        })

    inflightRequests.set(key, promise)
    return promise
}

export async function apiJsonDataCached<T>(
    input: string,
    init?: RequestInit,
    options?: { ttlMs?: number; errorTtlMs?: number }
): Promise<T> {
    const payload = await apiJsonCached<ApiEnvelope<T> | T>(input, init, options)
    return unwrapApiData(payload)
}
