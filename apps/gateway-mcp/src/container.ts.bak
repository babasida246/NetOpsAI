import { ChatOrchestrator, PolicyEngine, RouterEngine, QualityChecker, ExecutorEngine } from '@application/core'
import { PgClient, ConversationRepo } from '@infra/postgres'
import { RedisClient, CacheService } from '@infra/redis'
import { OpenRouterClient } from '@providers/llm'
import { PinoLogger } from '@observability/logger'
import { getModelByTier } from '@config/core'
import { ModelTier } from '@contracts/shared'
import { z } from 'zod'

const EnvSchema = z.object({
    DATABASE_URL: z.string().url(),
    REDIS_URL: z.string().url(),
    OPENROUTER_API_KEY: z.string().min(1),
    LOG_LEVEL: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
    PORT: z.coerce.number().default(3001)
})

export type Env = z.infer<typeof EnvSchema>

export interface MCPContainer {
    chatOrchestrator: ChatOrchestrator
    pgClient: PgClient
    redisClient: RedisClient
    logger: PinoLogger
    env: Env
}

export async function createMCPContainer(): Promise<MCPContainer> {
    // Validate environment
    const env = EnvSchema.parse(process.env)

    // Logger
    const logger = new PinoLogger({
        level: env.LOG_LEVEL,
        pretty: process.env.NODE_ENV !== 'production'
    })

    logger.info('Initializing MCP container', { env: process.env.NODE_ENV })

    // Postgres
    const pgClient = new PgClient({
        connectionString: env.DATABASE_URL,
        max: 10,
        min: 2
    })

    const pgHealthy = await pgClient.healthCheck()
    if (!pgHealthy) {
        throw new Error('Postgres health check failed')
    }
    logger.info('Postgres connected')

    // Redis
    const redisClient = new RedisClient({
        url: env.REDIS_URL,
        keyPrefix: 'hospital_gateway:'
    })

    await redisClient.connect()
    const redisHealthy = await redisClient.healthCheck()
    if (!redisHealthy) {
        throw new Error('Redis health check failed')
    }
    logger.info('Redis connected')

    // Repositories
    const conversationRepo = new ConversationRepo(pgClient)
    const cacheService = new CacheService(redisClient)

    // LLM Client
    const llmClient = new OpenRouterClient({
        apiKey: env.OPENROUTER_API_KEY,
        baseURL: 'https://openrouter.ai/api/v1',
        defaultModel: getModelByTier(ModelTier.T0_FREE).id
    })

    logger.info('LLM client initialized', {
        provider: 'openrouter',
        defaultModel: getModelByTier(ModelTier.T0_FREE).displayName
    })

    // Application Services
    const policyEngine = new PolicyEngine(
        {
            budgetLimitPerUser: 100,
            rateLimitWindow: 60000,
            rateLimitMax: 100,
            allowedTools: []
        },
        logger
    )

    const routerEngine = new RouterEngine(logger)
    const qualityChecker = new QualityChecker(logger)
    const executorEngine = new ExecutorEngine(llmClient, logger)

    // Chat Orchestrator
    const chatOrchestrator = new ChatOrchestrator(
        policyEngine,
        routerEngine,
        qualityChecker,
        llmClient,
        conversationRepo,
        cacheService,
        executorEngine,
        logger
    )

    logger.info('MCP container initialized successfully')

    return {
        chatOrchestrator,
        pgClient,
        redisClient,
        logger,
        env
    }
}

export async function closeMCPContainer(container: MCPContainer): Promise<void> {
    container.logger.info('Closing MCP container')
    await container.redisClient.disconnect()
    await container.pgClient.close()
    container.logger.info('MCP container closed')
}
