import { Redis } from 'ioredis'
import { z } from 'zod'

const ConfigSchema = z.object({
    url: z.string().url(),
    keyPrefix: z.string().default('hospital_gateway:'),
    maxRetriesPerRequest: z.number().default(3)
})

export type RedisConfig = z.infer<typeof ConfigSchema> & {
    retryStrategy?: (times: number) => number | void | null
}

export class RedisClient {
    private client: Redis

    constructor(config: RedisConfig) {
        const validated = {
            ...ConfigSchema.parse(config),
            retryStrategy: config.retryStrategy
        }

        this.client = new Redis(validated.url, {
            keyPrefix: validated.keyPrefix,
            maxRetriesPerRequest: validated.maxRetriesPerRequest,
            retryStrategy: validated.retryStrategy || this.defaultRetryStrategy,
            lazyConnect: true
        })

        this.client.on('error', (err: Error) => {
            console.error('Redis error', err)
        })

        this.client.on('connect', () => {
            console.log('Redis connected')
        })
    }

    async connect(): Promise<void> {
        await this.client.connect()
    }

    async get(key: string): Promise<string | null> {
        return await this.client.get(key)
    }

    async set(key: string, value: string, ttlSeconds?: number): Promise<void> {
        if (ttlSeconds) {
            await this.client.setex(key, ttlSeconds, value)
        } else {
            await this.client.set(key, value)
        }
    }

    async del(key: string): Promise<void> {
        await this.client.del(key)
    }

    async exists(key: string): Promise<boolean> {
        const result = await this.client.exists(key)
        return result === 1
    }

    async incr(key: string): Promise<number> {
        return await this.client.incr(key)
    }

    async expire(key: string, seconds: number): Promise<void> {
        await this.client.expire(key, seconds)
    }

    async healthCheck(): Promise<boolean> {
        try {
            const result = await this.client.ping()
            return result === 'PONG'
        } catch {
            return false
        }
    }

    async close(): Promise<void> {
        await this.client.quit()
    }

    private defaultRetryStrategy(times: number): number | void {
        if (times > 10) {
            return undefined // Stop retrying
        }
        return Math.min(times * 50, 2000) // Exponential backoff
    }
}
