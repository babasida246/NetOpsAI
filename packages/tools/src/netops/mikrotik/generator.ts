import type {
    MikroTikFullConfigIntent,
    MikroTikFullConfigOutput,
    MikroTikPlanStep,
    MikroTikRiskReport,
    MikroTikValidationReport
} from './types.js'
import { applyRoleDefaults, getRoleTemplate } from './roles.js'
import { calcDhcpPool, escapeRouterOsComment, formatSection, ipInCidr, parseCidr, uniqLines } from './utils.js'
import { validateIntent, validateRouterOsConfig } from './validation.js'

const COMMENT_TAG = 'NETOPSAI'

type Generated = {
    sections: Array<{ title: string; lines: string[] }>
    rollbackSections: Array<{ title: string; lines: string[] }>
    plan: MikroTikPlanStep[]
    assumptions: string[]
}

const slug = (value: string): string =>
    value
        .trim()
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '')
        .slice(0, 20) || 'vlan'

const roleBridgeName = (role: MikroTikFullConfigIntent['role']): string => {
    switch (role) {
        case 'edge-internet':
            return 'br-lan'
        case 'access-switch-crs':
            return 'br-sw'
        default:
            return 'br-core'
    }
}

const includeRouting = (role: MikroTikFullConfigIntent['role']): boolean =>
    role !== 'access-switch-crs' && role !== 'mgmt-only'

const includeNat = (role: MikroTikFullConfigIntent['role']): boolean => role === 'edge-internet'

const environmentTier = (intent: MikroTikFullConfigIntent) => intent.environment ?? 'dev'

export function generateMikrotikFullConfig(rawIntent: MikroTikFullConfigIntent): MikroTikFullConfigOutput {
    const intent = applyRoleDefaults(rawIntent)
    const template = getRoleTemplate(intent.role)

    const intentValidation = validateIntent(intent)
    const generated = buildConfig(intent)

    const config = renderScript(intent, generated.sections)
    const rollback = renderScript(intent, generated.rollbackSections, true)

    const configValidation = validateRouterOsConfig(config, intent.device.routerOsVersion)
    const validation: MikroTikValidationReport = mergeValidation(intentValidation, configValidation)

    const risk = evaluateRisk(intent, validation, generated.assumptions)

    const versionNotes: string[] = []
    if (intent.device.routerOsMajor !== 7) {
        versionNotes.push(`This tool targets RouterOS 7; detected routerOsMajor=${intent.device.routerOsMajor}.`)
    }
    if (!intent.device.routerOsVersion.startsWith('7')) {
        versionNotes.push(`RouterOS version '${intent.device.routerOsVersion}' may require adjustments.`)
    }

    if (template.requiredInputs.length > 0) {
        generated.assumptions.unshift(
            `Role template '${intent.role}' assumes required inputs: ${template.requiredInputs.join(', ')}.`
        )
    }

    return {
        config,
        rollback,
        validation,
        plan: generated.plan,
        risk,
        assumptions: generated.assumptions,
        versionNotes
    }
}

function mergeValidation(a: MikroTikValidationReport, b: MikroTikValidationReport): MikroTikValidationReport {
    const errors = [...a.errors, ...b.errors]
    const warnings = [...a.warnings, ...b.warnings]
    return {
        valid: errors.length === 0,
        errors,
        warnings
    }
}

function renderScript(intent: MikroTikFullConfigIntent, sections: Array<{ title: string; lines: string[] }>, isRollback = false): string {
    const header = [
        `# Generated by NetworkChangeMCP (${COMMENT_TAG})`,
        `# Role: ${intent.role}`,
        `# Hostname: ${intent.hostname}`,
        `# RouterOS: ${intent.device.routerOsVersion}`,
        `# Environment: ${environmentTier(intent)}`,
        isRollback ? '# Mode: ROLLBACK' : '# Mode: APPLY',
        ''
    ].join('\n')

    const body = sections
        .map((section) => formatSection(section.title, section.lines))
        .filter(Boolean)
        .join('\n')

    return `${header}${body}`.trimEnd() + '\n'
}

function buildConfig(intent: MikroTikFullConfigIntent): Generated {
    const sections: Array<{ title: string; lines: string[] }> = []
    const rollbackSections: Array<{ title: string; lines: string[] }> = []
    const plan: MikroTikPlanStep[] = []
    const assumptions: string[] = []

    const bridgeName = roleBridgeName(intent.role)
    const vlanList = intent.vlans ?? []
    const wanInterface = intent.internet?.wanInterface || intent.interfaces.find((iface) => iface.purpose === 'wan')?.name || ''

    // =====================
    // BASE / DAY-0
    // =====================
    const baseLines: string[] = []
    const baseRollback: string[] = []

    baseLines.push(`/system identity set name=${escapeRouterOsComment(intent.hostname)}`)

    const timezone = intent.management.timezone ?? 'Asia/Ho_Chi_Minh'
    assumptions.push(`timezone defaulted to '${timezone}'.`)
    baseLines.push(`/system clock set time-zone-name="${escapeRouterOsComment(timezone)}"`)

    const ntpServers = uniqLines(intent.management.ntpServers ?? [])
    if (ntpServers.length > 0) {
        baseLines.push('/system ntp client set enabled=yes')
        if (ntpServers[0]) baseLines.push(`/system ntp client set primary-ntp=${ntpServers[0]}`)
        if (ntpServers[1]) baseLines.push(`/system ntp client set secondary-ntp=${ntpServers[1]}`)
    } else {
        assumptions.push('No NTP servers provided; NTP client will remain default/disabled.')
    }

    const dnsServers = uniqLines(intent.internet?.dnsServers ?? [])
    if (dnsServers.length > 0) {
        baseLines.push(`/ip dns set servers=${dnsServers.join(',')}`)
    }

    // Services hardening (safe-by-default). Rollback does NOT re-enable services.
    baseLines.push('/ip service set telnet disabled=yes')
    baseLines.push('/ip service set ftp disabled=yes')
    baseLines.push('/ip service set www disabled=yes')
    baseLines.push('/ip service set api disabled=yes')
    baseLines.push('/ip service set api-ssl disabled=yes')

    // =====================
    // BRIDGE / VLAN
    // =====================
    const l2Lines: string[] = []
    const l2Rollback: string[] = []

    const needsBridge = intent.role !== 'mgmt-only' && (vlanList.length > 0 || intent.interfaces.some((i) => i.purpose !== 'wan'))
    if (needsBridge) {
        l2Lines.push(`/interface bridge add name=${bridgeName} vlan-filtering=yes comment="${COMMENT_TAG}"`)
        l2Rollback.push(`/interface bridge remove [find name=${bridgeName}]`)
    }

    // Bridge ports + VLAN membership (minimal safe defaults).
    for (const iface of intent.interfaces) {
        if (!needsBridge) break
        if (iface.purpose === 'wan') continue

        const comment = escapeRouterOsComment(`${COMMENT_TAG}:${iface.purpose}${iface.comment ? ` ${iface.comment}` : ''}`)
        l2Lines.push(`/interface bridge port add bridge=${bridgeName} interface=${iface.name} comment="${comment}"`)
        l2Rollback.push(`/interface bridge port remove [find bridge=${bridgeName} interface=${iface.name}]`)
    }

    const vlanInterfaceNames: Array<{ vlanId: number; iface: string }> = []
    for (const vlan of vlanList) {
        const name = `vlan${vlan.id}-${slug(vlan.name)}`
        vlanInterfaceNames.push({ vlanId: vlan.id, iface: name })
        if (needsBridge) {
            l2Lines.push(`/interface vlan add name=${name} vlan-id=${vlan.id} interface=${bridgeName} comment="${COMMENT_TAG}:${vlan.name}"`)
            l2Rollback.push(`/interface vlan remove [find name=${name}]`)
        }
    }

    // Bridge VLAN table
    if (needsBridge && vlanList.length > 0) {
        for (const vlan of vlanList) {
            const taggedPorts = intent.interfaces.filter((iface) => iface.purpose === 'trunk' && (iface.trunkVlanIds?.includes(vlan.id) ?? true))
            const untaggedPorts = intent.interfaces.filter((iface) => iface.purpose === 'access' && iface.accessVlanId === vlan.id)
            const tagged = [bridgeName, ...taggedPorts.map((p) => p.name)].join(',')
            const untagged = untaggedPorts.map((p) => p.name).join(',')

            l2Lines.push(
                `/interface bridge vlan add bridge=${bridgeName} vlan-ids=${vlan.id} tagged=${tagged}` +
                    (untagged ? ` untagged=${untagged}` : '') +
                    ` comment="${COMMENT_TAG}:vlan-table"`
            )
            l2Rollback.push(`/interface bridge vlan remove [find bridge=${bridgeName} vlan-ids=${vlan.id}]`)

            for (const accessPort of untaggedPorts) {
                l2Lines.push(`/interface bridge port set [find bridge=${bridgeName} interface=${accessPort.name}] pvid=${vlan.id}`)
            }
        }
    }

    // =====================
    // IP / DHCP
    // =====================
    const ipLines: string[] = []
    const ipRollback: string[] = []

    if (includeRouting(intent.role)) {
        for (const vlan of vlanList) {
            const ifaceName = vlanInterfaceNames.find((i) => i.vlanId === vlan.id)?.iface
            if (!ifaceName) continue

            const cidr = parseCidr(vlan.subnet)
            const prefix = cidr?.prefix ?? 24
            ipLines.push(`/ip address add address=${vlan.gateway}/${prefix} interface=${ifaceName} comment="${COMMENT_TAG}:gw vlan${vlan.id}"`)
            ipRollback.push(`/ip address remove [find comment~"${COMMENT_TAG}:gw vlan${vlan.id}"]`)

            const dhcp = vlan.dhcp
            if (dhcp?.enabled) {
                const pool = calcDhcpPool(vlan.subnet)
                const poolStart = dhcp.poolStart ?? pool?.poolStart
                const poolEnd = dhcp.poolEnd ?? pool?.poolEnd
                if (!poolStart || !poolEnd) {
                    assumptions.push(`DHCP pool for VLAN ${vlan.id} could not be computed; DHCP will be skipped.`)
                    continue
                }

                // Safety: ensure pool is inside subnet.
                const startIn = ipInCidr(poolStart, vlan.subnet)
                const endIn = ipInCidr(poolEnd, vlan.subnet)
                if (startIn === false || endIn === false) {
                    assumptions.push(`DHCP pool range for VLAN ${vlan.id} is outside subnet; DHCP will be skipped.`)
                    continue
                }

                const poolName = `pool-vlan${vlan.id}`
                const serverName = `dhcp-vlan${vlan.id}`

                ipLines.push(`/ip pool add name=${poolName} ranges=${poolStart}-${poolEnd} comment="${COMMENT_TAG}:dhcp vlan${vlan.id}"`)
                ipLines.push(
                    `/ip dhcp-server add name=${serverName} interface=${ifaceName} address-pool=${poolName} disabled=no comment="${COMMENT_TAG}:dhcp vlan${vlan.id}"`
                )
                ipLines.push(
                    `/ip dhcp-server network add address=${vlan.subnet} gateway=${vlan.gateway}` +
                        ` dns-server=${(dhcp.dnsServers?.length ? dhcp.dnsServers : dnsServers).join(',') || vlan.gateway}` +
                        (dhcp.ntpServers?.length ? ` ntp-server=${dhcp.ntpServers.join(',')}` : '') +
                        ` comment="${COMMENT_TAG}:dhcp network vlan${vlan.id}"`
                )

                ipRollback.push(`/ip dhcp-server network remove [find comment~"${COMMENT_TAG}:dhcp network vlan${vlan.id}"]`)
                ipRollback.push(`/ip dhcp-server remove [find comment~"${COMMENT_TAG}:dhcp vlan${vlan.id}"]`)
                ipRollback.push(`/ip pool remove [find comment~"${COMMENT_TAG}:dhcp vlan${vlan.id}"]`)
            }
        }
    }

    // =====================
    // ROUTING
    // =====================
    const routingLines: string[] = []
    const routingRollback: string[] = []

    if (includeRouting(intent.role) && intent.routing?.staticRoutes?.length) {
        for (const route of intent.routing.staticRoutes) {
            routingLines.push(
                `/ip route add dst-address=${route.dst} gateway=${route.gateway}` +
                    (route.distance ? ` distance=${route.distance}` : '') +
                    ` comment="${escapeRouterOsComment(`${COMMENT_TAG}:static ${route.dst}`)}"`
            )
            routingRollback.push(`/ip route remove [find comment~"${COMMENT_TAG}:static ${route.dst}"]`)
        }
    }

    // Default route based on internet config.
    if (includeRouting(intent.role) && intent.internet && intent.internet.defaultRoute !== false) {
        if (intent.internet.publicType === 'static') {
            routingLines.push(`/ip route add dst-address=0.0.0.0/0 gateway=${intent.internet.gateway} comment="${COMMENT_TAG}:default-route"`)
            routingRollback.push(`/ip route remove [find comment~"${COMMENT_TAG}:default-route"]`)
        }
    }

    // OSPF (RouterOS v7)
    if (includeRouting(intent.role) && intent.routing?.ospf?.enabled) {
        const ospf = intent.routing.ospf
        const area = ospf.area ?? '0.0.0.0'
        routingLines.push(
            `/routing ospf instance add name=${COMMENT_TAG}-ospf ` +
                `router-id=${ospf.routerId ?? vlanList[0]?.gateway ?? '0.0.0.0'} ` +
                `comment="${COMMENT_TAG}:ospf"`
        )
        routingLines.push(
            `/routing ospf area add name=${COMMENT_TAG}-area0 ` +
                `area-id=${area} ` +
                `instance=${COMMENT_TAG}-ospf ` +
                `comment="${COMMENT_TAG}:ospf"`
        )
        for (const cidr of ospf.networks ?? vlanList.map((v) => v.subnet)) {
            routingLines.push(`/routing ospf interface-template add networks=${cidr} area=${COMMENT_TAG}-area0 comment="${COMMENT_TAG}:ospf"`)
        }
        for (const passive of ospf.passiveInterfaces ?? []) {
            // RouterOS v7 supports matching by interface name in templates.
            routingLines.push(
                `/routing ospf interface-template add interfaces=${passive} passive=yes area=${COMMENT_TAG}-area0 comment="${COMMENT_TAG}:ospf passive ${escapeRouterOsComment(passive)}"`
            )
        }
        routingRollback.push(`/routing ospf interface-template remove [find comment~"${COMMENT_TAG}:ospf"]`)
        routingRollback.push(`/routing ospf area remove [find comment~"${COMMENT_TAG}:ospf"]`)
        routingRollback.push(`/routing ospf instance remove [find comment~"${COMMENT_TAG}:ospf"]`)
    }

    // =====================
    // FIREWALL / NAT / SECURITY
    // =====================
    const fwLines: string[] = []
    const fwRollback: string[] = []

    const preset = intent.securityProfile.preset
    const mgmtList = `${COMMENT_TAG}_MGMT`
    const lanList = `${COMMENT_TAG}_LAN`
    const wanList = `${COMMENT_TAG}_WAN`

    // Interface lists and membership
    fwLines.push('/interface list')
    fwLines.push(`:if ([:len [find name="${wanList}"]] = 0) do={ add name="${wanList}" comment="${COMMENT_TAG}" }`)
    fwLines.push(`:if ([:len [find name="${lanList}"]] = 0) do={ add name="${lanList}" comment="${COMMENT_TAG}" }`)
    fwLines.push(`:if ([:len [find name="${mgmtList}"]] = 0) do={ add name="${mgmtList}" comment="${COMMENT_TAG}" }`)

    if (wanInterface) {
        fwLines.push(`/interface list member add list="${wanList}" interface=${wanInterface} comment="${COMMENT_TAG}:wan"`)
        fwRollback.push(`/interface list member remove [find comment~"${COMMENT_TAG}:wan"]`)
    }

    for (const iface of intent.interfaces) {
        if (iface.purpose === 'wan') continue
        fwLines.push(`/interface list member add list="${lanList}" interface=${iface.name} comment="${COMMENT_TAG}:lan"`)
        if (iface.purpose === 'mgmt') {
            fwLines.push(`/interface list member add list="${mgmtList}" interface=${iface.name} comment="${COMMENT_TAG}:mgmt"`)
        }
    }
    fwRollback.push(`/interface list member remove [find comment~"${COMMENT_TAG}:lan"]`)
    fwRollback.push(`/interface list member remove [find comment~"${COMMENT_TAG}:mgmt"]`)

    // Address list for management subnet (always required)
    fwLines.push('/ip firewall address-list')
    fwLines.push(`/ip firewall address-list add list=${mgmtList} address=${intent.management.mgmtSubnet} comment="${COMMENT_TAG}:mgmt"`)
    for (const allowed of intent.management.allowedSubnets ?? []) {
        fwLines.push(`/ip firewall address-list add list=${mgmtList} address=${allowed} comment="${COMMENT_TAG}:mgmt"`)
    }
    fwRollback.push(`/ip firewall address-list remove [find comment~"${COMMENT_TAG}:mgmt"]`)

    // Optional user-defined address lists
    for (const list of intent.firewallPolicy?.addressLists ?? []) {
        for (const entry of list.entries) {
            fwLines.push(`/ip firewall address-list add list=${escapeRouterOsComment(list.name)} address=${entry} comment="${COMMENT_TAG}:addrlist"`)
        }
    }
    fwRollback.push(`/ip firewall address-list remove [find comment~"${COMMENT_TAG}:addrlist"]`)

    // Firewall baseline rules
    fwLines.push('/ip firewall filter')
    fwLines.push(`/ip firewall filter add chain=input connection-state=established,related action=accept comment="${COMMENT_TAG}:input established"`)
    fwLines.push(`/ip firewall filter add chain=input connection-state=invalid action=drop comment="${COMMENT_TAG}:input invalid"`)
    fwLines.push(`/ip firewall filter add chain=input protocol=icmp action=accept comment="${COMMENT_TAG}:input icmp"`)

    const sshPort = intent.management.ssh?.port ?? 22
    const winboxEnabled = intent.management.winbox?.enabled !== false
    const winboxPort = intent.management.winbox?.port ?? 8291

    fwLines.push(
        `/ip firewall filter add chain=input src-address-list=${mgmtList} protocol=tcp dst-port=${sshPort} action=accept comment="${COMMENT_TAG}:input ssh mgmt"`
    )
    if (winboxEnabled) {
        fwLines.push(
            `/ip firewall filter add chain=input src-address-list=${mgmtList} protocol=tcp dst-port=${winboxPort} action=accept comment="${COMMENT_TAG}:input winbox mgmt"`
        )
    }

    // If DNS remote requests are enabled, ensure port 53 is only allowed from LAN
    if (intent.management.dnsAllowRemoteRequests) {
        fwLines.push(
            `/ip firewall filter add chain=input in-interface-list="${lanList}" protocol=udp dst-port=53 action=accept comment="${COMMENT_TAG}:input dns udp"`
        )
        fwLines.push(
            `/ip firewall filter add chain=input in-interface-list="${lanList}" protocol=tcp dst-port=53 action=accept comment="${COMMENT_TAG}:input dns tcp"`
        )
    }

    // Drop from WAN (never allow all from WAN unless labMode)
    if (!intent.labMode) {
        fwLines.push(`/ip firewall filter add chain=input in-interface-list="${wanList}" action=drop comment="${COMMENT_TAG}:drop wan input"`)
    } else {
        assumptions.push('labMode=true: WAN drop rule is not enforced (NOT recommended for production).')
    }

    fwLines.push(`/ip firewall filter add chain=input action=drop comment="${COMMENT_TAG}:input drop"`)

    // Forward chain
    fwLines.push(`/ip firewall filter add chain=forward connection-state=established,related action=accept comment="${COMMENT_TAG}:fwd established"`)
    fwLines.push(`/ip firewall filter add chain=forward connection-state=invalid action=drop comment="${COMMENT_TAG}:fwd invalid"`)

    if (includeNat(intent.role) || intent.role === 'edge-internet') {
        fwLines.push(
            `/ip firewall filter add chain=forward in-interface-list="${lanList}" out-interface-list="${wanList}" action=accept comment="${COMMENT_TAG}:lan to wan"`
        )
    }

    // Inter-VLAN matrix (optional). Assumes user supplied address-list names.
    for (const rule of intent.firewallPolicy?.interVlanMatrix ?? []) {
        const comment = escapeRouterOsComment(`${COMMENT_TAG}:matrix ${rule.from}->${rule.to}`)
        fwLines.push(
            `/ip firewall filter add chain=forward src-address-list=${escapeRouterOsComment(rule.from)} dst-address-list=${escapeRouterOsComment(rule.to)} action=${rule.action === 'allow' ? 'accept' : 'drop'} comment="${comment}"`
        )
    }

    if (preset !== 'lab') {
        fwLines.push(`/ip firewall filter add chain=forward action=drop comment="${COMMENT_TAG}:fwd drop"`)
    }

    fwRollback.push(`/ip firewall filter remove [find comment~"${COMMENT_TAG}:"]`)

    // NAT
    const natLines: string[] = []
    const natRollback: string[] = []
    if (includeNat(intent.role) && intent.internet) {
        natLines.push('/ip firewall nat')
        natLines.push(`/ip firewall nat add chain=srcnat out-interface-list="${wanList}" action=masquerade comment="${COMMENT_TAG}:nat masquerade"`)
        natRollback.push(`/ip firewall nat remove [find comment~"${COMMENT_TAG}:nat"]`)
    }

    // =====================
    // SERVICES
    // =====================
    const svcLines: string[] = []
    const svcRollback: string[] = []

    const sshAllowPassword = intent.management.ssh?.allowPassword ?? false
    svcLines.push(`/ip service set ssh disabled=no port=${sshPort}`)
    if (!sshAllowPassword && intent.management.ssh?.authorizedKeys?.length) {
        assumptions.push('SSH keys were provided; user creation/import is out-of-scope for this minimal generator.')
    }

    // Winbox
    if (winboxEnabled) {
        svcLines.push(`/ip service set winbox disabled=no port=${winboxPort}`)
    } else {
        svcLines.push('/ip service set winbox disabled=yes')
    }

    // DNS remote requests flag (must be paired with firewall rules above)
    svcLines.push(`/ip dns set allow-remote-requests=${intent.management.dnsAllowRemoteRequests ? 'yes' : 'no'}`)

    // Syslog
    if (intent.management.syslog?.remote) {
        svcLines.push('/system logging action')
        svcLines.push(
            `/system logging action add name=${COMMENT_TAG}-remote target=remote remote=${intent.management.syslog.remote} comment="${COMMENT_TAG}:syslog"`
        )
        svcLines.push('/system logging')
        const topics = (intent.management.syslog.topics?.length ? intent.management.syslog.topics : ['info']).join(',')
        svcLines.push(`/system logging add topics=${topics} action=${COMMENT_TAG}-remote comment="${COMMENT_TAG}:syslog"`)
        svcRollback.push(`/system logging remove [find comment~"${COMMENT_TAG}:syslog"]`)
        svcRollback.push(`/system logging action remove [find comment~"${COMMENT_TAG}:syslog"]`)
    }

    // SNMP (optional)
    if (intent.management.snmp?.enabled) {
        svcLines.push('/snmp set enabled=yes')
        if (intent.management.snmp.community) {
            svcLines.push(`/snmp community set [find default=yes] name=${escapeRouterOsComment(intent.management.snmp.community)}`)
        }
        svcRollback.push('# NOTE: SNMP rollback is best-effort; review /snmp settings manually.')
    }

    // =====================
    // OPTIONAL (QoS / VPN - minimal placeholders)
    // =====================
    const optLines: string[] = []
    const optRollback: string[] = []

    if (intent.qos?.enabled) {
        assumptions.push(`QoS profile '${intent.qos.profile}' requested, but only placeholders are generated.`)
        optLines.push(`# QoS placeholder - profile: ${intent.qos.profile}`)
        optLines.push('# Implement queue tree + mangle rules per your policy.')
    }

    if (intent.vpn?.wireguard?.enabled) {
        assumptions.push('WireGuard requested, but only minimal placeholders are generated.')
        optLines.push('# WireGuard placeholder (review keys, allowed-ips, and firewall).')
    }

    // =====================
    // Assemble
    // =====================
    addSection(sections, rollbackSections, plan, 'BASE', baseLines, baseRollback)
    addSection(sections, rollbackSections, plan, 'BRIDGE/VLAN', l2Lines, l2Rollback)
    addSection(sections, rollbackSections, plan, 'IP/DHCP', ipLines, ipRollback)
    addSection(sections, rollbackSections, plan, 'ROUTING', routingLines, routingRollback)
    addSection(sections, rollbackSections, plan, 'FIREWALL', fwLines, fwRollback)
    addSection(sections, rollbackSections, plan, 'NAT', natLines, natRollback)
    addSection(sections, rollbackSections, plan, 'SERVICES', svcLines, svcRollback)
    addSection(sections, rollbackSections, plan, 'OPTIONAL', optLines, optRollback)

    return {
        sections,
        rollbackSections,
        plan,
        assumptions
    }
}

function addSection(
    sections: Array<{ title: string; lines: string[] }>,
    rollbackSections: Array<{ title: string; lines: string[] }>,
    plan: MikroTikPlanStep[],
    title: string,
    lines: string[],
    rollbackLines: string[]
) {
    const normalized = uniqLines(lines)
    const normalizedRollback = uniqLines(rollbackLines)
    sections.push({ title, lines: normalized })
    rollbackSections.push({ title, lines: normalizedRollback })
    plan.push({
        module: title.toLowerCase().replace(/[^a-z0-9]+/g, '_'),
        title,
        affected: normalized.length
    })
}

function evaluateRisk(
    intent: MikroTikFullConfigIntent,
    validation: MikroTikValidationReport,
    assumptions: string[]
): MikroTikRiskReport {
    const reasons: string[] = []
    const env = environmentTier(intent)
    let level: MikroTikRiskReport['level'] = 'low'

    const elevate = (target: MikroTikRiskReport['level']) => {
        const order = { low: 0, medium: 1, high: 2 } as const
        if (order[target] > order[level]) level = target
    }

    if (intent.role === 'access-switch-crs') {
        reasons.push('Bridge VLAN filtering changes can disconnect trunk/access ports if applied incorrectly.')
        elevate('high')
    }

    if (intent.management.dnsAllowRemoteRequests) {
        reasons.push('DNS allow-remote-requests is enabled; ensure firewall input rules restrict port 53 to trusted networks.')
        elevate(env === 'prod' ? 'high' : 'medium')
    }

    if (intent.management.ssh?.allowPassword) {
        reasons.push('SSH password authentication is enabled; prefer SSH keys for privileged access.')
        elevate(env === 'prod' ? 'high' : 'medium')
    }

    const mgmt = intent.management.mgmtSubnet
    const mgmtParsed = parseCidr(mgmt)
    if (mgmtParsed && mgmtParsed.prefix < 24) {
        reasons.push(`Management subnet ${mgmt} is wide (prefix /${mgmtParsed.prefix}); reduce blast radius if possible.`)
        elevate('high')
    }

    if (!validation.valid) {
        reasons.push('Validation errors detected; config should not be pushed until fixed.')
        elevate('high')
    }

    if (intent.labMode) {
        reasons.push('labMode is enabled, which may relax WAN protections. Do not use in production.')
        elevate('high')
    }

    if (assumptions.some((item) => item.toLowerCase().includes('placeholder'))) {
        reasons.push('Some sections contain placeholders; review before applying.')
        elevate('medium')
    }

    if (reasons.length === 0) {
        reasons.push('No high-risk changes detected based on the provided intent.')
    }

    return { level, reasons }
}
